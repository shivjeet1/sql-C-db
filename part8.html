<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Part 8 - B-Tree Leaf Node Format | Let’s Build a Simple Database</title>
<meta name="generator" content="Jekyll v3.9.5" />
<meta property="og:title" content="Part 8 - B-Tree Leaf Node Format" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="We’re changing the format of our table from an unsorted array of rows to a B-Tree. This is a pretty big change that is going to take multiple articles to implement. By the end of this article, we’ll define the layout of a leaf node and support inserting key/value pairs into a single-node tree. But first, let’s recap the reasons for switching to a tree structure." />
<meta property="og:description" content="We’re changing the format of our table from an unsorted array of rows to a B-Tree. This is a pretty big change that is going to take multiple articles to implement. By the end of this article, we’ll define the layout of a leaf node and support inserting key/value pairs into a single-node tree. But first, let’s recap the reasons for switching to a tree structure." />
<link rel="canonical" href="https://cstack.github.io/db_tutorial/parts/part8.html" />
<meta property="og:url" content="https://cstack.github.io/db_tutorial/parts/part8.html" />
<meta property="og:site_name" content="Let’s Build a Simple Database" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-09-25T00:00:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Part 8 - B-Tree Leaf Node Format" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2017-09-25T00:00:00+00:00","datePublished":"2017-09-25T00:00:00+00:00","description":"We’re changing the format of our table from an unsorted array of rows to a B-Tree. This is a pretty big change that is going to take multiple articles to implement. By the end of this article, we’ll define the layout of a leaf node and support inserting key/value pairs into a single-node tree. But first, let’s recap the reasons for switching to a tree structure.","headline":"Part 8 - B-Tree Leaf Node Format","mainEntityOfPage":{"@type":"WebPage","@id":"https://cstack.github.io/db_tutorial/parts/part8.html"},"url":"https://cstack.github.io/db_tutorial/parts/part8.html"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/db_tutorial/assets/css/style.css?v=60b50c5b7be787a4aaa1e50ab8a90c6cabb75159">
    <meta name="viewport" content="width=device-width">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>Let's Build a Simple Database</h1>
        <p>Writing a sqlite clone from scratch in C</p>

        <p class="view"><a href="/db_tutorial/">Overview</a></p>

        
          <p class="view"><a href="https://github.com/cstack/db_tutorial">View on GitHub (pull requests welcome)</a></p>
        

        

        

        <div style="color:#721c24;background-color:#f8d7da;border-color:#f5c6cb;padding:.75rem 1.25rem;border-radius:.25rem;margin-bottom:1rem">
          <p><b>This project is no longer under active development.</b> You can read more <a href="/db_tutorial/parts/part15.html">here</a>. But if you'd like to keep learning how to make your own SQLite clone from scratch, or one of many other projects like Docker, Redis, Git or BitTorrent, try <a href="https://app.codecrafters.io/join?via=cstack"><b>CodeCrafters</b></a>.</p>
        </div>
        <div>
          <a href="https://app.codecrafters.io/join?via=cstack"><img src="https://cstack.github.io/db_tutorial/assets/images/code-crafters.jpeg" alt=""/></a>
        </div>
      </header>
      <section>

      
      

      <h1>Part 8 - B-Tree Leaf Node Format</h1>
      
          <p><a class="prev" href="/db_tutorial/parts/part7.html">Part 7 - Introduction to the B-Tree</a> <br></p>
      
      
          <p><a class="next" href="/db_tutorial/parts/part9.html">Part 9 - Binary Search and Duplicate Keys</a> <br></p>
      

      <p>We’re changing the format of our table from an unsorted array of rows to a B-Tree. This is a pretty big change that is going to take multiple articles to implement. By the end of this article, we’ll define the layout of a leaf node and support inserting key/value pairs into a single-node tree. But first, let’s recap the reasons for switching to a tree structure.</p>

<h2 id="alternative-table-formats">Alternative Table Formats</h2>

<p>With the current format, each page stores only rows (no metadata) so it is pretty space efficient. Insertion is also fast because we just append to the end. However, finding a particular row can only be done by scanning the entire table. And if we want to delete a row, we have to fill in the hole by moving every row that comes after it.</p>

<p>If we stored the table as an array, but kept rows sorted by id, we could use binary search to find a particular id. However, insertion would be slow because we would have to move a lot of rows to make space.</p>

<p>Instead, we’re going with a tree structure. Each node in the tree can contain a variable number of rows, so we have to store some information in each node to keep track of how many rows it contains. Plus there is the storage overhead of all the internal nodes which don’t store any rows. In exchange for a larger database file, we get fast insertion, deletion and lookup.</p>

<table>
  <thead>
    <tr>
      <th> </th>
      <th>Unsorted Array of rows</th>
      <th>Sorted Array of rows</th>
      <th>Tree of nodes</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Pages contain</td>
      <td>only data</td>
      <td>only data</td>
      <td>metadata, primary keys, and data</td>
    </tr>
    <tr>
      <td>Rows per page</td>
      <td>more</td>
      <td>more</td>
      <td>fewer</td>
    </tr>
    <tr>
      <td>Insertion</td>
      <td>O(1)</td>
      <td>O(n)</td>
      <td>O(log(n))</td>
    </tr>
    <tr>
      <td>Deletion</td>
      <td>O(n)</td>
      <td>O(n)</td>
      <td>O(log(n))</td>
    </tr>
    <tr>
      <td>Lookup by id</td>
      <td>O(n)</td>
      <td>O(log(n))</td>
      <td>O(log(n))</td>
    </tr>
  </tbody>
</table>

<h2 id="node-header-format">Node Header Format</h2>

<p>Leaf nodes and internal nodes have different layouts. Let’s make an enum to keep track of node type:</p>

<div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gi">+typedef enum { NODE_INTERNAL, NODE_LEAF } NodeType;
</span></code></pre></div></div>

<p>Each node will correspond to one page. Internal nodes will point to their children by storing the page number that stores the child. The btree asks the pager for a particular page number and gets back a pointer into the page cache. Pages are stored in the database file one after the other in order of page number.</p>

<p>Nodes need to store some metadata in a header at the beginning of the page. Every node will store what type of node it is, whether or not it is the root node, and a pointer to its parent (to allow finding a node’s siblings). I define constants for the size and offset of every header field:</p>

<div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gi">+/*
+ * Common Node Header Layout
+ */
+const uint32_t NODE_TYPE_SIZE = sizeof(uint8_t);
+const uint32_t NODE_TYPE_OFFSET = 0;
+const uint32_t IS_ROOT_SIZE = sizeof(uint8_t);
+const uint32_t IS_ROOT_OFFSET = NODE_TYPE_SIZE;
+const uint32_t PARENT_POINTER_SIZE = sizeof(uint32_t);
+const uint32_t PARENT_POINTER_OFFSET = IS_ROOT_OFFSET + IS_ROOT_SIZE;
+const uint8_t COMMON_NODE_HEADER_SIZE =
+    NODE_TYPE_SIZE + IS_ROOT_SIZE + PARENT_POINTER_SIZE;
</span></code></pre></div></div>

<h2 id="leaf-node-format">Leaf Node Format</h2>

<p>In addition to these common header fields, leaf nodes need to store how many “cells” they contain. A cell is a key/value pair.</p>

<div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gi">+/*
+ * Leaf Node Header Layout
+ */
+const uint32_t LEAF_NODE_NUM_CELLS_SIZE = sizeof(uint32_t);
+const uint32_t LEAF_NODE_NUM_CELLS_OFFSET = COMMON_NODE_HEADER_SIZE;
+const uint32_t LEAF_NODE_HEADER_SIZE =
+    COMMON_NODE_HEADER_SIZE + LEAF_NODE_NUM_CELLS_SIZE;
</span></code></pre></div></div>

<p>The body of a leaf node is an array of cells. Each cell is a key followed by a value (a serialized row).</p>

<div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gi">+/*
+ * Leaf Node Body Layout
+ */
+const uint32_t LEAF_NODE_KEY_SIZE = sizeof(uint32_t);
+const uint32_t LEAF_NODE_KEY_OFFSET = 0;
+const uint32_t LEAF_NODE_VALUE_SIZE = ROW_SIZE;
+const uint32_t LEAF_NODE_VALUE_OFFSET =
+    LEAF_NODE_KEY_OFFSET + LEAF_NODE_KEY_SIZE;
+const uint32_t LEAF_NODE_CELL_SIZE = LEAF_NODE_KEY_SIZE + LEAF_NODE_VALUE_SIZE;
+const uint32_t LEAF_NODE_SPACE_FOR_CELLS = PAGE_SIZE - LEAF_NODE_HEADER_SIZE;
+const uint32_t LEAF_NODE_MAX_CELLS =
+    LEAF_NODE_SPACE_FOR_CELLS / LEAF_NODE_CELL_SIZE;
</span></code></pre></div></div>

<p>Based on these constants, here’s what the layout of a leaf node looks like currently:</p>

<table class="image">
<caption align="bottom">Our leaf node format</caption>
<tr><td><a href="https://cstack.github.io/db_tutorial/assets/images/leaf-node-format.png"><img src="https://cstack.github.io/db_tutorial/assets/images/leaf-node-format.png" alt="Our leaf node format" /></a></td></tr>
</table>

<p>It’s a little space inefficient to use an entire byte per boolean value in the header, but this makes it easier to write code to access those values.</p>

<p>Also notice that there’s some wasted space at the end. We store as many cells as we can after the header, but the leftover space can’t hold an entire cell. We leave it empty to avoid splitting cells between nodes.</p>

<h2 id="accessing-leaf-node-fields">Accessing Leaf Node Fields</h2>

<p>The code to access keys, values and metadata all involve pointer arithmetic using the constants we just defined.</p>

<div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gi">+uint32_t* leaf_node_num_cells(void* node) {
+  return node + LEAF_NODE_NUM_CELLS_OFFSET;
+}
+
+void* leaf_node_cell(void* node, uint32_t cell_num) {
+  return node + LEAF_NODE_HEADER_SIZE + cell_num * LEAF_NODE_CELL_SIZE;
+}
+
+uint32_t* leaf_node_key(void* node, uint32_t cell_num) {
+  return leaf_node_cell(node, cell_num);
+}
+
+void* leaf_node_value(void* node, uint32_t cell_num) {
+  return leaf_node_cell(node, cell_num) + LEAF_NODE_KEY_SIZE;
+}
+
+void initialize_leaf_node(void* node) { *leaf_node_num_cells(node) = 0; }
+
</span></code></pre></div></div>

<p>These methods return a pointer to the value in question, so they can be used both as a getter and a setter.</p>

<h2 id="changes-to-pager-and-table-objects">Changes to Pager and Table Objects</h2>

<p>Every node is going to take up exactly one page, even if it’s not full. That means our pager no longer needs to support reading/writing partial pages.</p>
<div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gd">-void pager_flush(Pager* pager, uint32_t page_num, uint32_t size) {
</span><span class="gi">+void pager_flush(Pager* pager, uint32_t page_num) {
</span>   if (pager-&gt;pages[page_num] == NULL) {
     printf("Tried to flush null page\n");
     exit(EXIT_FAILURE);
<span class="p">@@ -242,7 +337,7 @@</span> void pager_flush(Pager* pager, uint32_t page_num, uint32_t size) {
   }
 
   ssize_t bytes_written =
<span class="gd">-      write(pager-&gt;file_descriptor, pager-&gt;pages[page_num], size);
</span><span class="gi">+      write(pager-&gt;file_descriptor, pager-&gt;pages[page_num], PAGE_SIZE);
</span> 
   if (bytes_written == -1) {
     printf("Error writing: %d\n", errno);
</code></pre></div></div>

<div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code> void db_close(Table* table) {
   Pager* pager = table-&gt;pager;
<span class="gd">-  uint32_t num_full_pages = table-&gt;num_rows / ROWS_PER_PAGE;
</span> 
<span class="gd">-  for (uint32_t i = 0; i &lt; num_full_pages; i++) {
</span><span class="gi">+  for (uint32_t i = 0; i &lt; pager-&gt;num_pages; i++) {
</span>     if (pager-&gt;pages[i] == NULL) {
       continue;
     }
<span class="gd">-    pager_flush(pager, i, PAGE_SIZE);
</span><span class="gi">+    pager_flush(pager, i);
</span>     free(pager-&gt;pages[i]);
     pager-&gt;pages[i] = NULL;
   }
 
<span class="gd">-  // There may be a partial page to write to the end of the file
-  // This should not be needed after we switch to a B-tree
-  uint32_t num_additional_rows = table-&gt;num_rows % ROWS_PER_PAGE;
-  if (num_additional_rows &gt; 0) {
-    uint32_t page_num = num_full_pages;
-    if (pager-&gt;pages[page_num] != NULL) {
-      pager_flush(pager, page_num, num_additional_rows * ROW_SIZE);
-      free(pager-&gt;pages[page_num]);
-      pager-&gt;pages[page_num] = NULL;
-    }
-  }
-
</span>   int result = close(pager-&gt;file_descriptor);
   if (result == -1) {
     printf("Error closing db file.\n");
</code></pre></div></div>

<p>Now it makes more sense to store the number of pages in our database rather than the number of rows. The number of pages should be associated with the pager object, not the table, since it’s the number of pages used by the database, not a particular table. A btree is identified by its root node page number, so the table object needs to keep track of that.</p>

<div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code> const uint32_t PAGE_SIZE = 4096;
 const uint32_t TABLE_MAX_PAGES = 100;
<span class="gd">-const uint32_t ROWS_PER_PAGE = PAGE_SIZE / ROW_SIZE;
-const uint32_t TABLE_MAX_ROWS = ROWS_PER_PAGE * TABLE_MAX_PAGES;
</span> 
 typedef struct {
   int file_descriptor;
   uint32_t file_length;
<span class="gi">+  uint32_t num_pages;
</span>   void* pages[TABLE_MAX_PAGES];
 } Pager;
 
 typedef struct {
   Pager* pager;
<span class="gd">-  uint32_t num_rows;
</span><span class="gi">+  uint32_t root_page_num;
</span> } Table;
</code></pre></div></div>

<div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">@@ -127,6 +200,10 @@</span> void* get_page(Pager* pager, uint32_t page_num) {
     }
 
     pager-&gt;pages[page_num] = page;
<span class="gi">+
+    if (page_num &gt;= pager-&gt;num_pages) {
+      pager-&gt;num_pages = page_num + 1;
+    }
</span>   }
 
   return pager-&gt;pages[page_num];
</code></pre></div></div>

<div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">@@ -184,6 +269,12 @@</span> Pager* pager_open(const char* filename) {
   Pager* pager = malloc(sizeof(Pager));
   pager-&gt;file_descriptor = fd;
   pager-&gt;file_length = file_length;
<span class="gi">+  pager-&gt;num_pages = (file_length / PAGE_SIZE);
+
+  if (file_length % PAGE_SIZE != 0) {
+    printf("Db file is not a whole number of pages. Corrupt file.\n");
+    exit(EXIT_FAILURE);
+  }
</span> 
   for (uint32_t i = 0; i &lt; TABLE_MAX_PAGES; i++) {
     pager-&gt;pages[i] = NULL;
</code></pre></div></div>

<h2 id="changes-to-the-cursor-object">Changes to the Cursor Object</h2>

<p>A cursor represents a position in the table. When our table was a simple array of rows, we could access a row given just the row number. Now that it’s a tree, we identify a position by the page number of the node, and the cell number within that node.</p>

<div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code> typedef struct {
   Table* table;
<span class="gd">-  uint32_t row_num;
</span><span class="gi">+  uint32_t page_num;
+  uint32_t cell_num;
</span>   bool end_of_table;  // Indicates a position one past the last element
 } Cursor;
</code></pre></div></div>

<div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code> Cursor* table_start(Table* table) {
   Cursor* cursor = malloc(sizeof(Cursor));
   cursor-&gt;table = table;
<span class="gd">-  cursor-&gt;row_num = 0;
-  cursor-&gt;end_of_table = (table-&gt;num_rows == 0);
</span><span class="gi">+  cursor-&gt;page_num = table-&gt;root_page_num;
+  cursor-&gt;cell_num = 0;
+
+  void* root_node = get_page(table-&gt;pager, table-&gt;root_page_num);
+  uint32_t num_cells = *leaf_node_num_cells(root_node);
+  cursor-&gt;end_of_table = (num_cells == 0);
</span> 
   return cursor;
 }
</code></pre></div></div>

<div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code> Cursor* table_end(Table* table) {
   Cursor* cursor = malloc(sizeof(Cursor));
   cursor-&gt;table = table;
<span class="gd">-  cursor-&gt;row_num = table-&gt;num_rows;
</span><span class="gi">+  cursor-&gt;page_num = table-&gt;root_page_num;
+
+  void* root_node = get_page(table-&gt;pager, table-&gt;root_page_num);
+  uint32_t num_cells = *leaf_node_num_cells(root_node);
+  cursor-&gt;cell_num = num_cells;
</span>   cursor-&gt;end_of_table = true;
 
   return cursor;
 }
</code></pre></div></div>

<div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code> void* cursor_value(Cursor* cursor) {
<span class="gd">-  uint32_t row_num = cursor-&gt;row_num;
-  uint32_t page_num = row_num / ROWS_PER_PAGE;
</span><span class="gi">+  uint32_t page_num = cursor-&gt;page_num;
</span>   void* page = get_page(cursor-&gt;table-&gt;pager, page_num);
<span class="gd">-  uint32_t row_offset = row_num % ROWS_PER_PAGE;
-  uint32_t byte_offset = row_offset * ROW_SIZE;
-  return page + byte_offset;
</span><span class="gi">+  return leaf_node_value(page, cursor-&gt;cell_num);
</span> }
</code></pre></div></div>

<div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code> void cursor_advance(Cursor* cursor) {
<span class="gd">-  cursor-&gt;row_num += 1;
-  if (cursor-&gt;row_num &gt;= cursor-&gt;table-&gt;num_rows) {
</span><span class="gi">+  uint32_t page_num = cursor-&gt;page_num;
+  void* node = get_page(cursor-&gt;table-&gt;pager, page_num);
+
+  cursor-&gt;cell_num += 1;
+  if (cursor-&gt;cell_num &gt;= (*leaf_node_num_cells(node))) {
</span>     cursor-&gt;end_of_table = true;
   }
 }
</code></pre></div></div>

<h2 id="insertion-into-a-leaf-node">Insertion Into a Leaf Node</h2>

<p>In this article we’re only going to implement enough to get a single-node tree. Recall from last article that a tree starts out as an empty leaf node:</p>

<table class="image">
<caption align="bottom">empty btree</caption>
<tr><td><a href="https://cstack.github.io/db_tutorial/assets/images/btree1.png"><img src="https://cstack.github.io/db_tutorial/assets/images/btree1.png" alt="empty btree" /></a></td></tr>
</table>

<p>Key/value pairs can be added until the leaf node is full:</p>

<table class="image">
<caption align="bottom">one-node btree</caption>
<tr><td><a href="https://cstack.github.io/db_tutorial/assets/images/btree2.png"><img src="https://cstack.github.io/db_tutorial/assets/images/btree2.png" alt="one-node btree" /></a></td></tr>
</table>

<p>When we open the database for the first time, the database file will be empty, so we initialize page 0 to be an empty leaf node (the root node):</p>

<div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code> Table* db_open(const char* filename) {
   Pager* pager = pager_open(filename);
<span class="gd">-  uint32_t num_rows = pager-&gt;file_length / ROW_SIZE;
</span> 
   Table* table = malloc(sizeof(Table));
   table-&gt;pager = pager;
<span class="gd">-  table-&gt;num_rows = num_rows;
</span><span class="gi">+  table-&gt;root_page_num = 0;
+
+  if (pager-&gt;num_pages == 0) {
+    // New database file. Initialize page 0 as leaf node.
+    void* root_node = get_page(pager, 0);
+    initialize_leaf_node(root_node);
+  }
</span> 
   return table;
 }
</code></pre></div></div>

<p>Next we’ll make a function for inserting a key/value pair into a leaf node. It will take a cursor as input to represent the position where the pair should be inserted.</p>

<div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gi">+void leaf_node_insert(Cursor* cursor, uint32_t key, Row* value) {
+  void* node = get_page(cursor-&gt;table-&gt;pager, cursor-&gt;page_num);
+
+  uint32_t num_cells = *leaf_node_num_cells(node);
+  if (num_cells &gt;= LEAF_NODE_MAX_CELLS) {
+    // Node full
+    printf("Need to implement splitting a leaf node.\n");
+    exit(EXIT_FAILURE);
+  }
+
+  if (cursor-&gt;cell_num &lt; num_cells) {
+    // Make room for new cell
+    for (uint32_t i = num_cells; i &gt; cursor-&gt;cell_num; i--) {
+      memcpy(leaf_node_cell(node, i), leaf_node_cell(node, i - 1),
+             LEAF_NODE_CELL_SIZE);
+    }
+  }
+
+  *(leaf_node_num_cells(node)) += 1;
+  *(leaf_node_key(node, cursor-&gt;cell_num)) = key;
+  serialize_row(value, leaf_node_value(node, cursor-&gt;cell_num));
+}
+
</span></code></pre></div></div>

<p>We haven’t implemented splitting yet, so we error if the node is full. Next we shift cells one space to the right to make room for the new cell. Then we write the new key/value into the empty space.</p>

<p>Since we assume the tree only has one node, our <code class="language-plaintext highlighter-rouge">execute_insert()</code> function simply needs to call this helper method:</p>

<div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code> ExecuteResult execute_insert(Statement* statement, Table* table) {
<span class="gd">-  if (table-&gt;num_rows &gt;= TABLE_MAX_ROWS) {
</span><span class="gi">+  void* node = get_page(table-&gt;pager, table-&gt;root_page_num);
+  if ((*leaf_node_num_cells(node) &gt;= LEAF_NODE_MAX_CELLS)) {
</span>     return EXECUTE_TABLE_FULL;
   }
 
   Row* row_to_insert = &amp;(statement-&gt;row_to_insert);
   Cursor* cursor = table_end(table);
 
<span class="gd">-  serialize_row(row_to_insert, cursor_value(cursor));
-  table-&gt;num_rows += 1;
</span><span class="gi">+  leaf_node_insert(cursor, row_to_insert-&gt;id, row_to_insert);
</span> 
   free(cursor);
</code></pre></div></div>

<p>With those changes, our database should work as before! Except now it returns a “Table Full” error much sooner, since we can’t split the root node yet.</p>

<p>How many rows can the leaf node hold?</p>

<h2 id="command-to-print-constants">Command to Print Constants</h2>

<p>I’m adding a new meta command to print out a few constants of interest.</p>

<div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gi">+void print_constants() {
+  printf("ROW_SIZE: %d\n", ROW_SIZE);
+  printf("COMMON_NODE_HEADER_SIZE: %d\n", COMMON_NODE_HEADER_SIZE);
+  printf("LEAF_NODE_HEADER_SIZE: %d\n", LEAF_NODE_HEADER_SIZE);
+  printf("LEAF_NODE_CELL_SIZE: %d\n", LEAF_NODE_CELL_SIZE);
+  printf("LEAF_NODE_SPACE_FOR_CELLS: %d\n", LEAF_NODE_SPACE_FOR_CELLS);
+  printf("LEAF_NODE_MAX_CELLS: %d\n", LEAF_NODE_MAX_CELLS);
+}
+
</span><span class="p">@@ -294,6 +376,14 @@</span> MetaCommandResult do_meta_command(InputBuffer* input_buffer, Table* table) {
   if (strcmp(input_buffer-&gt;buffer, ".exit") == 0) {
     db_close(table);
     exit(EXIT_SUCCESS);
<span class="gi">+  } else if (strcmp(input_buffer-&gt;buffer, ".constants") == 0) {
+    printf("Constants:\n");
+    print_constants();
+    return META_COMMAND_SUCCESS;
</span>   } else {
     return META_COMMAND_UNRECOGNIZED_COMMAND;
   }
</code></pre></div></div>

<p>I’m also adding a test so we get alerted when those constants change:</p>
<div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gi">+  it 'prints constants' do
+    script = [
+      ".constants",
+      ".exit",
+    ]
+    result = run_script(script)
+
+    expect(result).to match_array([
+      "db &gt; Constants:",
+      "ROW_SIZE: 293",
+      "COMMON_NODE_HEADER_SIZE: 6",
+      "LEAF_NODE_HEADER_SIZE: 10",
+      "LEAF_NODE_CELL_SIZE: 297",
+      "LEAF_NODE_SPACE_FOR_CELLS: 4086",
+      "LEAF_NODE_MAX_CELLS: 13",
+      "db &gt; ",
+    ])
+  end
</span></code></pre></div></div>

<p>So our table can hold 13 rows right now!</p>

<h2 id="tree-visualization">Tree Visualization</h2>

<p>To help with debugging and visualization, I’m also adding a meta command to print out a representation of the btree.</p>

<div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gi">+void print_leaf_node(void* node) {
+  uint32_t num_cells = *leaf_node_num_cells(node);
+  printf("leaf (size %d)\n", num_cells);
+  for (uint32_t i = 0; i &lt; num_cells; i++) {
+    uint32_t key = *leaf_node_key(node, i);
+    printf("  - %d : %d\n", i, key);
+  }
+}
+
</span></code></pre></div></div>

<div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">@@ -294,6 +376,14 @@</span> MetaCommandResult do_meta_command(InputBuffer* input_buffer, Table* table) {
   if (strcmp(input_buffer-&gt;buffer, ".exit") == 0) {
     db_close(table);
     exit(EXIT_SUCCESS);
<span class="gi">+  } else if (strcmp(input_buffer-&gt;buffer, ".btree") == 0) {
+    printf("Tree:\n");
+    print_leaf_node(get_page(table-&gt;pager, 0));
+    return META_COMMAND_SUCCESS;
</span>   } else if (strcmp(input_buffer-&gt;buffer, ".constants") == 0) {
     printf("Constants:\n");
     print_constants();
     return META_COMMAND_SUCCESS;
   } else {
     return META_COMMAND_UNRECOGNIZED_COMMAND;
   }
</code></pre></div></div>

<p>And a test</p>

<div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gi">+  it 'allows printing out the structure of a one-node btree' do
+    script = [3, 1, 2].map do |i|
+      "insert #{i} user#{i} person#{i}@example.com"
+    end
+    script &lt;&lt; ".btree"
+    script &lt;&lt; ".exit"
+    result = run_script(script)
+
+    expect(result).to match_array([
+      "db &gt; Executed.",
+      "db &gt; Executed.",
+      "db &gt; Executed.",
+      "db &gt; Tree:",
+      "leaf (size 3)",
+      "  - 0 : 3",
+      "  - 1 : 1",
+      "  - 2 : 2",
+      "db &gt; "
+    ])
+  end
</span></code></pre></div></div>

<p>Uh oh, we’re still not storing rows in sorted order. You’ll notice that <code class="language-plaintext highlighter-rouge">execute_insert()</code> inserts into the leaf node at the position returned by <code class="language-plaintext highlighter-rouge">table_end()</code>. So rows are stored in the order they were inserted, just like before.</p>

<h2 id="next-time">Next Time</h2>

<p>This all might seem like a step backwards. Our database now stores fewer rows than it did before, and we’re still storing rows in unsorted order. But like I said at the beginning, this is a big change and it’s important to break it up into manageable steps.</p>

<p>Next time, we’ll implement finding a record by primary key, and start storing rows in sorted order.</p>

<h2 id="complete-diff">Complete Diff</h2>

<div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">@@ -62,29 +62,101 @@</span> const uint32_t ROW_SIZE = ID_SIZE + USERNAME_SIZE + EMAIL_SIZE;

 const uint32_t PAGE_SIZE = 4096;
 #define TABLE_MAX_PAGES 100
<span class="gd">-const uint32_t ROWS_PER_PAGE = PAGE_SIZE / ROW_SIZE;
-const uint32_t TABLE_MAX_ROWS = ROWS_PER_PAGE * TABLE_MAX_PAGES;
</span> 
 typedef struct {
   int file_descriptor;
   uint32_t file_length;
<span class="gi">+  uint32_t num_pages;
</span>   void* pages[TABLE_MAX_PAGES];
 } Pager;
 
 typedef struct {
   Pager* pager;
<span class="gd">-  uint32_t num_rows;
</span><span class="gi">+  uint32_t root_page_num;
</span> } Table;
 
 typedef struct {
   Table* table;
<span class="gd">-  uint32_t row_num;
</span><span class="gi">+  uint32_t page_num;
+  uint32_t cell_num;
</span>   bool end_of_table;  // Indicates a position one past the last element
 } Cursor;

+typedef enum { NODE_INTERNAL, NODE_LEAF } NodeType;
<span class="gi">+
+/*
+ * Common Node Header Layout
+ */
+const uint32_t NODE_TYPE_SIZE = sizeof(uint8_t);
+const uint32_t NODE_TYPE_OFFSET = 0;
+const uint32_t IS_ROOT_SIZE = sizeof(uint8_t);
+const uint32_t IS_ROOT_OFFSET = NODE_TYPE_SIZE;
+const uint32_t PARENT_POINTER_SIZE = sizeof(uint32_t);
+const uint32_t PARENT_POINTER_OFFSET = IS_ROOT_OFFSET + IS_ROOT_SIZE;
+const uint8_t COMMON_NODE_HEADER_SIZE =
+    NODE_TYPE_SIZE + IS_ROOT_SIZE + PARENT_POINTER_SIZE;
+
+/*
+ * Leaf Node Header Layout
+ */
+const uint32_t LEAF_NODE_NUM_CELLS_SIZE = sizeof(uint32_t);
+const uint32_t LEAF_NODE_NUM_CELLS_OFFSET = COMMON_NODE_HEADER_SIZE;
+const uint32_t LEAF_NODE_HEADER_SIZE =
+    COMMON_NODE_HEADER_SIZE + LEAF_NODE_NUM_CELLS_SIZE;
+
+/*
+ * Leaf Node Body Layout
+ */
+const uint32_t LEAF_NODE_KEY_SIZE = sizeof(uint32_t);
+const uint32_t LEAF_NODE_KEY_OFFSET = 0;
+const uint32_t LEAF_NODE_VALUE_SIZE = ROW_SIZE;
+const uint32_t LEAF_NODE_VALUE_OFFSET =
+    LEAF_NODE_KEY_OFFSET + LEAF_NODE_KEY_SIZE;
+const uint32_t LEAF_NODE_CELL_SIZE = LEAF_NODE_KEY_SIZE + LEAF_NODE_VALUE_SIZE;
+const uint32_t LEAF_NODE_SPACE_FOR_CELLS = PAGE_SIZE - LEAF_NODE_HEADER_SIZE;
+const uint32_t LEAF_NODE_MAX_CELLS =
+    LEAF_NODE_SPACE_FOR_CELLS / LEAF_NODE_CELL_SIZE;
+
+uint32_t* leaf_node_num_cells(void* node) {
+  return node + LEAF_NODE_NUM_CELLS_OFFSET;
+}
+
+void* leaf_node_cell(void* node, uint32_t cell_num) {
+  return node + LEAF_NODE_HEADER_SIZE + cell_num * LEAF_NODE_CELL_SIZE;
+}
+
+uint32_t* leaf_node_key(void* node, uint32_t cell_num) {
+  return leaf_node_cell(node, cell_num);
+}
+
+void* leaf_node_value(void* node, uint32_t cell_num) {
+  return leaf_node_cell(node, cell_num) + LEAF_NODE_KEY_SIZE;
+}
+
+void print_constants() {
+  printf("ROW_SIZE: %d\n", ROW_SIZE);
+  printf("COMMON_NODE_HEADER_SIZE: %d\n", COMMON_NODE_HEADER_SIZE);
+  printf("LEAF_NODE_HEADER_SIZE: %d\n", LEAF_NODE_HEADER_SIZE);
+  printf("LEAF_NODE_CELL_SIZE: %d\n", LEAF_NODE_CELL_SIZE);
+  printf("LEAF_NODE_SPACE_FOR_CELLS: %d\n", LEAF_NODE_SPACE_FOR_CELLS);
+  printf("LEAF_NODE_MAX_CELLS: %d\n", LEAF_NODE_MAX_CELLS);
+}
+
+void print_leaf_node(void* node) {
+  uint32_t num_cells = *leaf_node_num_cells(node);
+  printf("leaf (size %d)\n", num_cells);
+  for (uint32_t i = 0; i &lt; num_cells; i++) {
+    uint32_t key = *leaf_node_key(node, i);
+    printf("  - %d : %d\n", i, key);
+  }
+}
+
</span> void print_row(Row* row) {
     printf("(%d, %s, %s)\n", row-&gt;id, row-&gt;username, row-&gt;email);
 }
<span class="p">@@ -101,6 +173,8 @@</span> void deserialize_row(void *source, Row* destination) {
     memcpy(&amp;(destination-&gt;email), source + EMAIL_OFFSET, EMAIL_SIZE);
 }
 
<span class="gi">+void initialize_leaf_node(void* node) { *leaf_node_num_cells(node) = 0; }
+
</span> void* get_page(Pager* pager, uint32_t page_num) {
   if (page_num &gt; TABLE_MAX_PAGES) {
     printf("Tried to fetch page number out of bounds. %d &gt; %d\n", page_num,
<span class="p">@@ -128,6 +202,10 @@</span> void* get_page(Pager* pager, uint32_t page_num) {
     }
 
     pager-&gt;pages[page_num] = page;
<span class="gi">+
+    if (page_num &gt;= pager-&gt;num_pages) {
+      pager-&gt;num_pages = page_num + 1;
+    }
</span>   }
 
   return pager-&gt;pages[page_num];
<span class="p">@@ -136,8 +214,12 @@</span> void* get_page(Pager* pager, uint32_t page_num) {
 Cursor* table_start(Table* table) {
   Cursor* cursor = malloc(sizeof(Cursor));
   cursor-&gt;table = table;
<span class="gd">-  cursor-&gt;row_num = 0;
-  cursor-&gt;end_of_table = (table-&gt;num_rows == 0);
</span><span class="gi">+  cursor-&gt;page_num = table-&gt;root_page_num;
+  cursor-&gt;cell_num = 0;
+
+  void* root_node = get_page(table-&gt;pager, table-&gt;root_page_num);
+  uint32_t num_cells = *leaf_node_num_cells(root_node);
+  cursor-&gt;end_of_table = (num_cells == 0);
</span> 
   return cursor;
 }
<span class="p">@@ -145,24 +227,28 @@</span> Cursor* table_start(Table* table) {
 Cursor* table_end(Table* table) {
   Cursor* cursor = malloc(sizeof(Cursor));
   cursor-&gt;table = table;
<span class="gd">-  cursor-&gt;row_num = table-&gt;num_rows;
</span><span class="gi">+  cursor-&gt;page_num = table-&gt;root_page_num;
+
+  void* root_node = get_page(table-&gt;pager, table-&gt;root_page_num);
+  uint32_t num_cells = *leaf_node_num_cells(root_node);
+  cursor-&gt;cell_num = num_cells;
</span>   cursor-&gt;end_of_table = true;
 
   return cursor;
 }
 
 void* cursor_value(Cursor* cursor) {
<span class="gd">-  uint32_t row_num = cursor-&gt;row_num;
-  uint32_t page_num = row_num / ROWS_PER_PAGE;
</span><span class="gi">+  uint32_t page_num = cursor-&gt;page_num;
</span>   void* page = get_page(cursor-&gt;table-&gt;pager, page_num);
<span class="gd">-  uint32_t row_offset = row_num % ROWS_PER_PAGE;
-  uint32_t byte_offset = row_offset * ROW_SIZE;
-  return page + byte_offset;
</span><span class="gi">+  return leaf_node_value(page, cursor-&gt;cell_num);
</span> }
 
 void cursor_advance(Cursor* cursor) {
<span class="gd">-  cursor-&gt;row_num += 1;
-  if (cursor-&gt;row_num &gt;= cursor-&gt;table-&gt;num_rows) {
</span><span class="gi">+  uint32_t page_num = cursor-&gt;page_num;
+  void* node = get_page(cursor-&gt;table-&gt;pager, page_num);
+
+  cursor-&gt;cell_num += 1;
+  if (cursor-&gt;cell_num &gt;= (*leaf_node_num_cells(node))) {
</span>     cursor-&gt;end_of_table = true;
   }
 }
<span class="p">@@ -185,6 +271,12 @@</span> Pager* pager_open(const char* filename) {
   Pager* pager = malloc(sizeof(Pager));
   pager-&gt;file_descriptor = fd;
   pager-&gt;file_length = file_length;
<span class="gi">+  pager-&gt;num_pages = (file_length / PAGE_SIZE);
+
+  if (file_length % PAGE_SIZE != 0) {
+    printf("Db file is not a whole number of pages. Corrupt file.\n");
+    exit(EXIT_FAILURE);
+  }
</span> 
   for (uint32_t i = 0; i &lt; TABLE_MAX_PAGES; i++) {
     pager-&gt;pages[i] = NULL;
<span class="p">@@ -194,11 +285,15 @@</span> Pager* pager_open(const char* filename) {
<span class="p">@@ -195,11 +287,16 @@</span> Pager* pager_open(const char* filename) {
 
 Table* db_open(const char* filename) {
   Pager* pager = pager_open(filename);
<span class="gd">-  uint32_t num_rows = pager-&gt;file_length / ROW_SIZE;
</span> 
   Table* table = malloc(sizeof(Table));
   table-&gt;pager = pager;
<span class="gd">-  table-&gt;num_rows = num_rows;
</span><span class="gi">+  table-&gt;root_page_num = 0;
+
+  if (pager-&gt;num_pages == 0) {
+    // New database file. Initialize page 0 as leaf node.
+    void* root_node = get_page(pager, 0);
+    initialize_leaf_node(root_node);
+  }
</span> 
   return table;
 }
<span class="p">@@ -234,7 +331,7 @@</span> void close_input_buffer(InputBuffer* input_buffer) {
     free(input_buffer);
 }
 
<span class="gd">-void pager_flush(Pager* pager, uint32_t page_num, uint32_t size) {
</span><span class="gi">+void pager_flush(Pager* pager, uint32_t page_num) {
</span>   if (pager-&gt;pages[page_num] == NULL) {
     printf("Tried to flush null page\n");
     exit(EXIT_FAILURE);
<span class="p">@@ -242,7 +337,7 @@</span> void pager_flush(Pager* pager, uint32_t page_num, uint32_t size) {
<span class="p">@@ -249,7 +346,7 @@</span> void pager_flush(Pager* pager, uint32_t page_num, uint32_t size) {
   }
 
   ssize_t bytes_written =
<span class="gd">-      write(pager-&gt;file_descriptor, pager-&gt;pages[page_num], size);
</span><span class="gi">+      write(pager-&gt;file_descriptor, pager-&gt;pages[page_num], PAGE_SIZE);
</span> 
   if (bytes_written == -1) {
     printf("Error writing: %d\n", errno);
<span class="p">@@ -252,29 +347,16 @@</span> void pager_flush(Pager* pager, uint32_t page_num, uint32_t size) {
<span class="p">@@ -260,29 +357,16 @@</span> void pager_flush(Pager* pager, uint32_t page_num, uint32_t size) {
 
 void db_close(Table* table) {
   Pager* pager = table-&gt;pager;
<span class="gd">-  uint32_t num_full_pages = table-&gt;num_rows / ROWS_PER_PAGE;
</span> 
<span class="gd">-  for (uint32_t i = 0; i &lt; num_full_pages; i++) {
</span><span class="gi">+  for (uint32_t i = 0; i &lt; pager-&gt;num_pages; i++) {
</span>     if (pager-&gt;pages[i] == NULL) {
       continue;
     }
<span class="gd">-    pager_flush(pager, i, PAGE_SIZE);
</span><span class="gi">+    pager_flush(pager, i);
</span>     free(pager-&gt;pages[i]);
     pager-&gt;pages[i] = NULL;
   }
 
<span class="gd">-  // There may be a partial page to write to the end of the file
-  // This should not be needed after we switch to a B-tree
-  uint32_t num_additional_rows = table-&gt;num_rows % ROWS_PER_PAGE;
-  if (num_additional_rows &gt; 0) {
-    uint32_t page_num = num_full_pages;
-    if (pager-&gt;pages[page_num] != NULL) {
-      pager_flush(pager, page_num, num_additional_rows * ROW_SIZE);
-      free(pager-&gt;pages[page_num]);
-      pager-&gt;pages[page_num] = NULL;
-    }
-  }
-
</span>   int result = close(pager-&gt;file_descriptor);
   if (result == -1) {
     printf("Error closing db file.\n");
<span class="p">@@ -305,6 +389,14 @@</span> MetaCommandResult do_meta_command(InputBuffer* input_buffer, Table *table) {
   if (strcmp(input_buffer-&gt;buffer, ".exit") == 0) {
     db_close(table);
     exit(EXIT_SUCCESS);
<span class="gi">+  } else if (strcmp(input_buffer-&gt;buffer, ".btree") == 0) {
+    printf("Tree:\n");
+    print_leaf_node(get_page(table-&gt;pager, 0));
+    return META_COMMAND_SUCCESS;
+  } else if (strcmp(input_buffer-&gt;buffer, ".constants") == 0) {
+    printf("Constants:\n");
+    print_constants();
+    return META_COMMAND_SUCCESS;
</span>   } else {
     return META_COMMAND_UNRECOGNIZED_COMMAND;
   }
<span class="p">@@ -354,16 +446,39 @@</span> PrepareResult prepare_statement(InputBuffer* input_buffer,
   return PREPARE_UNRECOGNIZED_STATEMENT;
 }
 
<span class="gi">+void leaf_node_insert(Cursor* cursor, uint32_t key, Row* value) {
+  void* node = get_page(cursor-&gt;table-&gt;pager, cursor-&gt;page_num);
+
+  uint32_t num_cells = *leaf_node_num_cells(node);
+  if (num_cells &gt;= LEAF_NODE_MAX_CELLS) {
+    // Node full
+    printf("Need to implement splitting a leaf node.\n");
+    exit(EXIT_FAILURE);
+  }
+
+  if (cursor-&gt;cell_num &lt; num_cells) {
+    // Make room for new cell
+    for (uint32_t i = num_cells; i &gt; cursor-&gt;cell_num; i--) {
+      memcpy(leaf_node_cell(node, i), leaf_node_cell(node, i - 1),
+             LEAF_NODE_CELL_SIZE);
+    }
+  }
+
+  *(leaf_node_num_cells(node)) += 1;
+  *(leaf_node_key(node, cursor-&gt;cell_num)) = key;
+  serialize_row(value, leaf_node_value(node, cursor-&gt;cell_num));
+}
+
</span> ExecuteResult execute_insert(Statement* statement, Table* table) {
<span class="gd">-  if (table-&gt;num_rows &gt;= TABLE_MAX_ROWS) {
</span><span class="gi">+  void* node = get_page(table-&gt;pager, table-&gt;root_page_num);
+  if ((*leaf_node_num_cells(node) &gt;= LEAF_NODE_MAX_CELLS)) {
</span>     return EXECUTE_TABLE_FULL;
   }
 
   Row* row_to_insert = &amp;(statement-&gt;row_to_insert);
   Cursor* cursor = table_end(table);
 
<span class="gd">-  serialize_row(row_to_insert, cursor_value(cursor));
-  table-&gt;num_rows += 1;
</span><span class="gi">+  leaf_node_insert(cursor, row_to_insert-&gt;id, row_to_insert);
</span> 
   free(cursor);
</code></pre></div></div>

<p>And the specs:</p>
<div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gi">+  it 'allows printing out the structure of a one-node btree' do
+    script = [3, 1, 2].map do |i|
+      "insert #{i} user#{i} person#{i}@example.com"
+    end
+    script &lt;&lt; ".btree"
+    script &lt;&lt; ".exit"
+    result = run_script(script)
+
+    expect(result).to match_array([
+      "db &gt; Executed.",
+      "db &gt; Executed.",
+      "db &gt; Executed.",
+      "db &gt; Tree:",
+      "leaf (size 3)",
+      "  - 0 : 3",
+      "  - 1 : 1",
+      "  - 2 : 2",
+      "db &gt; "
+    ])
+  end
+
+  it 'prints constants' do
+    script = [
+      ".constants",
+      ".exit",
+    ]
+    result = run_script(script)
+
+    expect(result).to match_array([
+      "db &gt; Constants:",
+      "ROW_SIZE: 293",
+      "COMMON_NODE_HEADER_SIZE: 6",
+      "LEAF_NODE_HEADER_SIZE: 10",
+      "LEAF_NODE_CELL_SIZE: 297",
+      "LEAF_NODE_SPACE_FOR_CELLS: 4086",
+      "LEAF_NODE_MAX_CELLS: 13",
+      "db &gt; ",
+    ])
+  end
</span> end
</code></pre></div></div>


      
          <p><a class="prev" href="/db_tutorial/parts/part7.html">Part 7 - Introduction to the B-Tree</a> <br></p>
      
      
          <p><a class="next" href="/db_tutorial/parts/part9.html">Part 9 - Binary Search and Duplicate Keys</a> <br></p>
      

      </section>
      <footer>
        
        <p><a href="/db_tutorial/feed.xml">rss</a> | <a href="https://ifttt.com/applets/60708433d-rss-feed-to-email">subscribe by email</a></p>
        <p>This project is maintained by <a href="https://github.com/cstack">cstack</a></p>
        
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="/db_tutorial/assets/js/scale.fix.js"></script>


  
    <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-105767942-1', 'auto');
        ga('send', 'pageview');
    </script>
  
  </body>
</html>
