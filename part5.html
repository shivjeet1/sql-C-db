<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Part 5 - Persistence to Disk | Let’s Build a Simple Database</title>
<meta name="generator" content="Jekyll v3.9.5" />
<meta property="og:title" content="Part 5 - Persistence to Disk" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="“Nothing in the world can take the place of persistence.” – Calvin Coolidge" />
<meta property="og:description" content="“Nothing in the world can take the place of persistence.” – Calvin Coolidge" />
<link rel="canonical" href="https://cstack.github.io/db_tutorial/parts/part5.html" />
<meta property="og:url" content="https://cstack.github.io/db_tutorial/parts/part5.html" />
<meta property="og:site_name" content="Let’s Build a Simple Database" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-09-08T00:00:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Part 5 - Persistence to Disk" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2017-09-08T00:00:00+00:00","datePublished":"2017-09-08T00:00:00+00:00","description":"“Nothing in the world can take the place of persistence.” – Calvin Coolidge","headline":"Part 5 - Persistence to Disk","mainEntityOfPage":{"@type":"WebPage","@id":"https://cstack.github.io/db_tutorial/parts/part5.html"},"url":"https://cstack.github.io/db_tutorial/parts/part5.html"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/db_tutorial/assets/css/style.css?v=60b50c5b7be787a4aaa1e50ab8a90c6cabb75159">
    <meta name="viewport" content="width=device-width">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>Let's Build a Simple Database</h1>
        <p>Writing a sqlite clone from scratch in C</p>

        <p class="view"><a href="/db_tutorial/">Overview</a></p>

        
          <p class="view"><a href="https://github.com/cstack/db_tutorial">View on GitHub (pull requests welcome)</a></p>
        

        

        

        <div style="color:#721c24;background-color:#f8d7da;border-color:#f5c6cb;padding:.75rem 1.25rem;border-radius:.25rem;margin-bottom:1rem">
          <p><b>This project is no longer under active development.</b> You can read more <a href="/db_tutorial/parts/part15.html">here</a>. But if you'd like to keep learning how to make your own SQLite clone from scratch, or one of many other projects like Docker, Redis, Git or BitTorrent, try <a href="https://app.codecrafters.io/join?via=cstack"><b>CodeCrafters</b></a>.</p>
        </div>
        <div>
          <a href="https://app.codecrafters.io/join?via=cstack"><img src="https://cstack.github.io/db_tutorial/assets/images/code-crafters.jpeg" alt=""/></a>
        </div>
      </header>
      <section>

      
      

      <h1>Part 5 - Persistence to Disk</h1>
      
          <p><a class="prev" href="/db_tutorial/parts/part4.html">Part 4 - Our First Tests (and Bugs)</a> <br></p>
      
      
          <p><a class="next" href="/db_tutorial/parts/part6.html">Part 6 - The Cursor Abstraction</a> <br></p>
      

      <blockquote>
  <p>“Nothing in the world can take the place of persistence.” – <a href="https://en.wikiquote.org/wiki/Calvin_Coolidge">Calvin Coolidge</a></p>
</blockquote>

<p>Our database lets you insert records and read them back out, but only as long as you keep the program running. If you kill the program and start it back up, all your records are gone. Here’s a spec for the behavior we want:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">it</span> <span class="s1">'keeps data after closing connection'</span> <span class="k">do</span>
  <span class="n">result1</span> <span class="o">=</span> <span class="n">run_script</span><span class="p">([</span>
    <span class="s2">"insert 1 user1 person1@example.com"</span><span class="p">,</span>
    <span class="s2">".exit"</span><span class="p">,</span>
  <span class="p">])</span>
  <span class="n">expect</span><span class="p">(</span><span class="n">result1</span><span class="p">).</span><span class="nf">to</span> <span class="n">match_array</span><span class="p">([</span>
    <span class="s2">"db &gt; Executed."</span><span class="p">,</span>
    <span class="s2">"db &gt; "</span><span class="p">,</span>
  <span class="p">])</span>
  <span class="n">result2</span> <span class="o">=</span> <span class="n">run_script</span><span class="p">([</span>
    <span class="s2">"select"</span><span class="p">,</span>
    <span class="s2">".exit"</span><span class="p">,</span>
  <span class="p">])</span>
  <span class="n">expect</span><span class="p">(</span><span class="n">result2</span><span class="p">).</span><span class="nf">to</span> <span class="n">match_array</span><span class="p">([</span>
    <span class="s2">"db &gt; (1, user1, person1@example.com)"</span><span class="p">,</span>
    <span class="s2">"Executed."</span><span class="p">,</span>
    <span class="s2">"db &gt; "</span><span class="p">,</span>
  <span class="p">])</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Like sqlite, we’re going to persist records by saving the entire database to a file.</p>

<p>We already set ourselves up to do that by serializing rows into page-sized memory blocks. To add persistence, we can simply write those blocks of memory to a file, and read them back into memory the next time the program starts up.</p>

<p>To make this easier, we’re going to make an abstraction called the pager. We ask the pager for page number <code class="language-plaintext highlighter-rouge">x</code>, and the pager gives us back a block of memory. It first looks in its cache. On a cache miss, it copies data from disk into memory (by reading the database file).</p>

<table class="image">
<caption align="bottom">How our program matches up with SQLite architecture</caption>
<tr><td><a href="https://cstack.github.io/db_tutorial/assets/images/arch-part5.gif"><img src="https://cstack.github.io/db_tutorial/assets/images/arch-part5.gif" alt="How our program matches up with SQLite architecture" /></a></td></tr>
</table>

<p>The Pager accesses the page cache and the file. The Table object makes requests for pages through the pager:</p>

<div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gi">+typedef struct {
+  int file_descriptor;
+  uint32_t file_length;
+  void* pages[TABLE_MAX_PAGES];
+} Pager;
+
</span> typedef struct {
<span class="gd">-  void* pages[TABLE_MAX_PAGES];
</span><span class="gi">+  Pager* pager;
</span>   uint32_t num_rows;
 } Table;
</code></pre></div></div>

<p>I’m renaming <code class="language-plaintext highlighter-rouge">new_table()</code> to <code class="language-plaintext highlighter-rouge">db_open()</code> because it now has the effect of opening a connection to the database. By opening a connection, I mean:</p>

<ul>
  <li>opening the database file</li>
  <li>initializing a pager data structure</li>
  <li>initializing a table data structure</li>
</ul>

<div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gd">-Table* new_table() {
</span><span class="gi">+Table* db_open(const char* filename) {
+  Pager* pager = pager_open(filename);
+  uint32_t num_rows = pager-&gt;file_length / ROW_SIZE;
+
</span>   Table* table = malloc(sizeof(Table));
<span class="gd">-  table-&gt;num_rows = 0;
</span><span class="gi">+  table-&gt;pager = pager;
+  table-&gt;num_rows = num_rows;
</span>
   return table;
 }
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">db_open()</code> in turn calls <code class="language-plaintext highlighter-rouge">pager_open()</code>, which opens the database file and keeps track of its size. It also initializes the page cache to all <code class="language-plaintext highlighter-rouge">NULL</code>s.</p>

<div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gi">+Pager* pager_open(const char* filename) {
+  int fd = open(filename,
+                O_RDWR |      // Read/Write mode
+                    O_CREAT,  // Create file if it does not exist
+                S_IWUSR |     // User write permission
+                    S_IRUSR   // User read permission
+                );
+
+  if (fd == -1) {
+    printf("Unable to open file\n");
+    exit(EXIT_FAILURE);
+  }
+
+  off_t file_length = lseek(fd, 0, SEEK_END);
+
+  Pager* pager = malloc(sizeof(Pager));
+  pager-&gt;file_descriptor = fd;
+  pager-&gt;file_length = file_length;
+
+  for (uint32_t i = 0; i &lt; TABLE_MAX_PAGES; i++) {
+    pager-&gt;pages[i] = NULL;
+  }
+
+  return pager;
+}
</span></code></pre></div></div>

<p>Following our new abstraction, we move the logic for fetching a page into its own method:</p>

<div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code> void* row_slot(Table* table, uint32_t row_num) {
   uint32_t page_num = row_num / ROWS_PER_PAGE;
<span class="gd">-  void* page = table-&gt;pages[page_num];
-  if (page == NULL) {
-    // Allocate memory only when we try to access page
-    page = table-&gt;pages[page_num] = malloc(PAGE_SIZE);
-  }
</span><span class="gi">+  void* page = get_page(table-&gt;pager, page_num);
</span>   uint32_t row_offset = row_num % ROWS_PER_PAGE;
   uint32_t byte_offset = row_offset * ROW_SIZE;
   return page + byte_offset;
 }
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">get_page()</code> method has the logic for handling a cache miss. We assume pages are saved one after the other in the database file: Page 0 at offset 0, page 1 at offset 4096, page 2 at offset 8192, etc. If the requested page lies outside the bounds of the file, we know it should be blank, so we just allocate some memory and return it. The page will be added to the file when we flush the cache to disk later.</p>

<div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gi">+void* get_page(Pager* pager, uint32_t page_num) {
+  if (page_num &gt; TABLE_MAX_PAGES) {
+    printf("Tried to fetch page number out of bounds. %d &gt; %d\n", page_num,
+           TABLE_MAX_PAGES);
+    exit(EXIT_FAILURE);
+  }
+
+  if (pager-&gt;pages[page_num] == NULL) {
+    // Cache miss. Allocate memory and load from file.
+    void* page = malloc(PAGE_SIZE);
+    uint32_t num_pages = pager-&gt;file_length / PAGE_SIZE;
+
+    // We might save a partial page at the end of the file
+    if (pager-&gt;file_length % PAGE_SIZE) {
+      num_pages += 1;
+    }
+
+    if (page_num &lt;= num_pages) {
+      lseek(pager-&gt;file_descriptor, page_num * PAGE_SIZE, SEEK_SET);
+      ssize_t bytes_read = read(pager-&gt;file_descriptor, page, PAGE_SIZE);
+      if (bytes_read == -1) {
+        printf("Error reading file: %d\n", errno);
+        exit(EXIT_FAILURE);
+      }
+    }
+
+    pager-&gt;pages[page_num] = page;
+  }
+
+  return pager-&gt;pages[page_num];
+}
</span></code></pre></div></div>

<p>For now, we’ll wait to flush the cache to disk until the user closes the connection to the database. When the user exits, we’ll call a new method called <code class="language-plaintext highlighter-rouge">db_close()</code>, which</p>

<ul>
  <li>flushes the page cache to disk</li>
  <li>closes the database file</li>
  <li>frees the memory for the Pager and Table data structures</li>
</ul>

<div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gi">+void db_close(Table* table) {
+  Pager* pager = table-&gt;pager;
+  uint32_t num_full_pages = table-&gt;num_rows / ROWS_PER_PAGE;
+
+  for (uint32_t i = 0; i &lt; num_full_pages; i++) {
+    if (pager-&gt;pages[i] == NULL) {
+      continue;
+    }
+    pager_flush(pager, i, PAGE_SIZE);
+    free(pager-&gt;pages[i]);
+    pager-&gt;pages[i] = NULL;
+  }
+
+  // There may be a partial page to write to the end of the file
+  // This should not be needed after we switch to a B-tree
+  uint32_t num_additional_rows = table-&gt;num_rows % ROWS_PER_PAGE;
+  if (num_additional_rows &gt; 0) {
+    uint32_t page_num = num_full_pages;
+    if (pager-&gt;pages[page_num] != NULL) {
+      pager_flush(pager, page_num, num_additional_rows * ROW_SIZE);
+      free(pager-&gt;pages[page_num]);
+      pager-&gt;pages[page_num] = NULL;
+    }
+  }
+
+  int result = close(pager-&gt;file_descriptor);
+  if (result == -1) {
+    printf("Error closing db file.\n");
+    exit(EXIT_FAILURE);
+  }
+  for (uint32_t i = 0; i &lt; TABLE_MAX_PAGES; i++) {
+    void* page = pager-&gt;pages[i];
+    if (page) {
+      free(page);
+      pager-&gt;pages[i] = NULL;
+    }
+  }
+  free(pager);
+  free(table);
+}
+
</span><span class="gd">-MetaCommandResult do_meta_command(InputBuffer* input_buffer) {
</span><span class="gi">+MetaCommandResult do_meta_command(InputBuffer* input_buffer, Table* table) {
</span>   if (strcmp(input_buffer-&gt;buffer, ".exit") == 0) {
<span class="gi">+    db_close(table);
</span>     exit(EXIT_SUCCESS);
   } else {
     return META_COMMAND_UNRECOGNIZED_COMMAND;
</code></pre></div></div>

<p>In our current design, the length of the file encodes how many rows are in the database, so we need to write a partial page at the end of the file. That’s why <code class="language-plaintext highlighter-rouge">pager_flush()</code> takes both a page number and a size. It’s not the greatest design, but it will go away pretty quickly when we start implementing the B-tree.</p>

<div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gi">+void pager_flush(Pager* pager, uint32_t page_num, uint32_t size) {
+  if (pager-&gt;pages[page_num] == NULL) {
+    printf("Tried to flush null page\n");
+    exit(EXIT_FAILURE);
+  }
+
+  off_t offset = lseek(pager-&gt;file_descriptor, page_num * PAGE_SIZE, SEEK_SET);
+
+  if (offset == -1) {
+    printf("Error seeking: %d\n", errno);
+    exit(EXIT_FAILURE);
+  }
+
+  ssize_t bytes_written =
+      write(pager-&gt;file_descriptor, pager-&gt;pages[page_num], size);
+
+  if (bytes_written == -1) {
+    printf("Error writing: %d\n", errno);
+    exit(EXIT_FAILURE);
+  }
+}
</span></code></pre></div></div>

<p>Lastly, we need to accept the filename as a command-line argument. Don’t forget to also add the extra argument to <code class="language-plaintext highlighter-rouge">do_meta_command</code>:</p>

<div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code> int main(int argc, char* argv[]) {
<span class="gd">-  Table* table = new_table();
</span><span class="gi">+  if (argc &lt; 2) {
+    printf("Must supply a database filename.\n");
+    exit(EXIT_FAILURE);
+  }
+
+  char* filename = argv[1];
+  Table* table = db_open(filename);
+
</span>   InputBuffer* input_buffer = new_input_buffer();
   while (true) {
     print_prompt();
     read_input(input_buffer);

     if (input_buffer-&gt;buffer[0] == '.') {
<span class="gd">-      switch (do_meta_command(input_buffer)) {
</span><span class="gi">+      switch (do_meta_command(input_buffer, table)) {
</span></code></pre></div></div>
<p>With these changes, we’re able to close then reopen the database, and our records are still there!</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>~ ./db mydb.db
db &gt; insert 1 cstack foo@bar.com
Executed.
db &gt; insert 2 voltorb volty@example.com
Executed.
db &gt; .exit
~
~ ./db mydb.db
db &gt; select
(1, cstack, foo@bar.com)
(2, voltorb, volty@example.com)
Executed.
db &gt; .exit
~
</code></pre></div></div>

<p>For extra fun, let’s take a look at <code class="language-plaintext highlighter-rouge">mydb.db</code> to see how our data is being stored. I’ll use vim as a hex editor to look at the memory layout of the file:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vim mydb.db
:%!xxd
</code></pre></div></div>
<table class="image">
<caption align="bottom">Current File Format</caption>
<tr><td><a href="https://cstack.github.io/db_tutorial/assets/images/file-format.png"><img src="https://cstack.github.io/db_tutorial/assets/images/file-format.png" alt="Current File Format" /></a></td></tr>
</table>

<p>The first four bytes are the id of the first row (4 bytes because we store a <code class="language-plaintext highlighter-rouge">uint32_t</code>). It’s stored in little-endian byte order, so the least significant byte comes first (01), followed by the higher-order bytes (00 00 00). We used <code class="language-plaintext highlighter-rouge">memcpy()</code> to copy bytes from our <code class="language-plaintext highlighter-rouge">Row</code> struct into the page cache, so that means the struct was laid out in memory in little-endian byte order. That’s an attribute of the machine I compiled the program for. If we wanted to write a database file on my machine, then read it on a big-endian machine, we’d have to change our <code class="language-plaintext highlighter-rouge">serialize_row()</code> and <code class="language-plaintext highlighter-rouge">deserialize_row()</code> methods to always store and read bytes in the same order.</p>

<p>The next 33 bytes store the username as a null-terminated string. Apparently “cstack” in ASCII hexadecimal is <code class="language-plaintext highlighter-rouge">63 73 74 61 63 6b</code>, followed by a null character (<code class="language-plaintext highlighter-rouge">00</code>). The rest of the 33 bytes are unused.</p>

<p>The next 256 bytes store the email in the same way. Here we can see some random junk after the terminating null character. This is most likely due to uninitialized memory in our <code class="language-plaintext highlighter-rouge">Row</code> struct. We copy the entire 256-byte email buffer into the file, including any bytes after the end of the string. Whatever was in memory when we allocated that struct is still there. But since we use a terminating null character, it has no effect on behavior.</p>

<p><strong>NOTE</strong>: If we wanted to ensure that all bytes are initialized, it would
suffice to use <code class="language-plaintext highlighter-rouge">strncpy</code> instead of <code class="language-plaintext highlighter-rouge">memcpy</code> while copying the <code class="language-plaintext highlighter-rouge">username</code>
and <code class="language-plaintext highlighter-rouge">email</code> fields of rows in <code class="language-plaintext highlighter-rouge">serialize_row</code>, like so:</p>

<div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code> void serialize_row(Row* source, void* destination) {
     memcpy(destination + ID_OFFSET, &amp;(source-&gt;id), ID_SIZE);
<span class="gd">-    memcpy(destination + USERNAME_OFFSET, &amp;(source-&gt;username), USERNAME_SIZE);
-    memcpy(destination + EMAIL_OFFSET, &amp;(source-&gt;email), EMAIL_SIZE);
</span><span class="gi">+    strncpy(destination + USERNAME_OFFSET, source-&gt;username, USERNAME_SIZE);
+    strncpy(destination + EMAIL_OFFSET, source-&gt;email, EMAIL_SIZE);
</span> }
</code></pre></div></div>

<h2 id="conclusion">Conclusion</h2>

<p>Alright! We’ve got persistence. It’s not the greatest. For example if you kill the program without typing <code class="language-plaintext highlighter-rouge">.exit</code>, you lose your changes. Additionally, we’re writing all pages back to disk, even pages that haven’t changed since we read them from disk. These are issues we can address later.</p>

<p>Next time we’ll introduce cursors, which should make it easier to implement the B-tree.</p>

<p>Until then!</p>

<h2 id="complete-diff">Complete Diff</h2>
<div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gi">+#include &lt;errno.h&gt;
+#include &lt;fcntl.h&gt;
</span> #include &lt;stdbool.h&gt;
 #include &lt;stdio.h&gt;
 #include &lt;stdlib.h&gt;
 #include &lt;string.h&gt;
 #include &lt;stdint.h&gt;
<span class="gi">+#include &lt;unistd.h&gt;
</span>
 struct InputBuffer_t {
   char* buffer;
<span class="p">@@ -62,9 +65,16 @@</span> const uint32_t PAGE_SIZE = 4096;
 const uint32_t ROWS_PER_PAGE = PAGE_SIZE / ROW_SIZE;
 const uint32_t TABLE_MAX_ROWS = ROWS_PER_PAGE * TABLE_MAX_PAGES;

+typedef struct {
<span class="gi">+  int file_descriptor;
+  uint32_t file_length;
+  void* pages[TABLE_MAX_PAGES];
+} Pager;
+
</span> typedef struct {
   uint32_t num_rows;
<span class="gd">-  void* pages[TABLE_MAX_PAGES];
</span><span class="gi">+  Pager* pager;
</span> } Table;

@@ -84,32 +94,81 @@ void deserialize_row(void *source, Row* destination) {
   memcpy(&amp;(destination-&gt;email), source + EMAIL_OFFSET, EMAIL_SIZE);
 }

+void* get_page(Pager* pager, uint32_t page_num) {
<span class="gi">+  if (page_num &gt; TABLE_MAX_PAGES) {
+     printf("Tried to fetch page number out of bounds. %d &gt; %d\n", page_num,
+     	TABLE_MAX_PAGES);
+     exit(EXIT_FAILURE);
+  }
+
+  if (pager-&gt;pages[page_num] == NULL) {
+     // Cache miss. Allocate memory and load from file.
+     void* page = malloc(PAGE_SIZE);
+     uint32_t num_pages = pager-&gt;file_length / PAGE_SIZE;
+
+     // We might save a partial page at the end of the file
+     if (pager-&gt;file_length % PAGE_SIZE) {
+         num_pages += 1;
+     }
+
+     if (page_num &lt;= num_pages) {
+         lseek(pager-&gt;file_descriptor, page_num * PAGE_SIZE, SEEK_SET);
+         ssize_t bytes_read = read(pager-&gt;file_descriptor, page, PAGE_SIZE);
+         if (bytes_read == -1) {
+     	printf("Error reading file: %d\n", errno);
+     	exit(EXIT_FAILURE);
+         }
+     }
+
+     pager-&gt;pages[page_num] = page;
+  }
+
+  return pager-&gt;pages[page_num];
+}
+
</span> void* row_slot(Table* table, uint32_t row_num) {
   uint32_t page_num = row_num / ROWS_PER_PAGE;
<span class="gd">-  void *page = table-&gt;pages[page_num];
-  if (page == NULL) {
-     // Allocate memory only when we try to access page
-     page = table-&gt;pages[page_num] = malloc(PAGE_SIZE);
-  }
</span><span class="gi">+  void *page = get_page(table-&gt;pager, page_num);
</span>   uint32_t row_offset = row_num % ROWS_PER_PAGE;
   uint32_t byte_offset = row_offset * ROW_SIZE;
   return page + byte_offset;
 }

-Table* new_table() {
<span class="gd">-  Table* table = malloc(sizeof(Table));
-  table-&gt;num_rows = 0;
</span><span class="gi">+Pager* pager_open(const char* filename) {
+  int fd = open(filename,
+     	  O_RDWR | 	// Read/Write mode
+     	      O_CREAT,	// Create file if it does not exist
+     	  S_IWUSR |	// User write permission
+     	      S_IRUSR	// User read permission
+     	  );
+
+  if (fd == -1) {
+     printf("Unable to open file\n");
+     exit(EXIT_FAILURE);
+  }
+
+  off_t file_length = lseek(fd, 0, SEEK_END);
+
+  Pager* pager = malloc(sizeof(Pager));
+  pager-&gt;file_descriptor = fd;
+  pager-&gt;file_length = file_length;
+
</span>   for (uint32_t i = 0; i &lt; TABLE_MAX_PAGES; i++) {
<span class="gd">-     table-&gt;pages[i] = NULL;
</span><span class="gi">+     pager-&gt;pages[i] = NULL;
</span>   }
<span class="gd">-  return table;
</span><span class="gi">+
+  return pager;
</span> }

-void free_table(Table* table) {
<span class="gd">-  for (int i = 0; table-&gt;pages[i]; i++) {
-     free(table-&gt;pages[i]);
-  }
-  free(table);
</span><span class="gi">+Table* db_open(const char* filename) {
+  Pager* pager = pager_open(filename);
+  uint32_t num_rows = pager-&gt;file_length / ROW_SIZE;
+
+  Table* table = malloc(sizeof(Table));
+  table-&gt;pager = pager;
+  table-&gt;num_rows = num_rows;
+
+  return table;
</span> }

 InputBuffer* new_input_buffer() {
<span class="p">@@ -142,10 +201,76 @@</span> void close_input_buffer(InputBuffer* input_buffer) {
   free(input_buffer);
 }

+void pager_flush(Pager* pager, uint32_t page_num, uint32_t size) {
<span class="gi">+  if (pager-&gt;pages[page_num] == NULL) {
+     printf("Tried to flush null page\n");
+     exit(EXIT_FAILURE);
+  }
+
+  off_t offset = lseek(pager-&gt;file_descriptor, page_num * PAGE_SIZE,
+     		 SEEK_SET);
+
+  if (offset == -1) {
+     printf("Error seeking: %d\n", errno);
+     exit(EXIT_FAILURE);
+  }
+
+  ssize_t bytes_written = write(
+     pager-&gt;file_descriptor, pager-&gt;pages[page_num], size
+     );
+
+  if (bytes_written == -1) {
+     printf("Error writing: %d\n", errno);
+     exit(EXIT_FAILURE);
+  }
+}
+
+void db_close(Table* table) {
+  Pager* pager = table-&gt;pager;
+  uint32_t num_full_pages = table-&gt;num_rows / ROWS_PER_PAGE;
+
+  for (uint32_t i = 0; i &lt; num_full_pages; i++) {
+     if (pager-&gt;pages[i] == NULL) {
+         continue;
+     }
+     pager_flush(pager, i, PAGE_SIZE);
+     free(pager-&gt;pages[i]);
+     pager-&gt;pages[i] = NULL;
+  }
+
+  // There may be a partial page to write to the end of the file
+  // This should not be needed after we switch to a B-tree
+  uint32_t num_additional_rows = table-&gt;num_rows % ROWS_PER_PAGE;
+  if (num_additional_rows &gt; 0) {
+     uint32_t page_num = num_full_pages;
+     if (pager-&gt;pages[page_num] != NULL) {
+         pager_flush(pager, page_num, num_additional_rows * ROW_SIZE);
+         free(pager-&gt;pages[page_num]);
+         pager-&gt;pages[page_num] = NULL;
+     }
+  }
+
+  int result = close(pager-&gt;file_descriptor);
+  if (result == -1) {
+     printf("Error closing db file.\n");
+     exit(EXIT_FAILURE);
+  }
+  for (uint32_t i = 0; i &lt; TABLE_MAX_PAGES; i++) {
+     void* page = pager-&gt;pages[i];
+     if (page) {
+         free(page);
+         pager-&gt;pages[i] = NULL;
+     }
+  }
+
+  free(pager);
+  free(table);
+}
+
</span> MetaCommandResult do_meta_command(InputBuffer* input_buffer, Table *table) {
   if (strcmp(input_buffer-&gt;buffer, ".exit") == 0) {
     close_input_buffer(input_buffer);
<span class="gd">-    free_table(table);
</span><span class="gi">+    db_close(table);
</span>     exit(EXIT_SUCCESS);
   } else {
     return META_COMMAND_UNRECOGNIZED_COMMAND;
<span class="p">@@ -182,6 +308,7 @@</span> PrepareResult prepare_insert(InputBuffer* input_buffer, Statement* statement) {
     return PREPARE_SUCCESS;

 }
<span class="gi">+
</span> PrepareResult prepare_statement(InputBuffer* input_buffer,
                                 Statement* statement) {
   if (strncmp(input_buffer-&gt;buffer, "insert", 6) == 0) {
<span class="p">@@ -227,7 +354,14 @@</span> ExecuteResult execute_statement(Statement* statement, Table *table) {
 }

 int main(int argc, char* argv[]) {
<span class="gd">-  Table* table = new_table();
</span><span class="gi">+  if (argc &lt; 2) {
+      printf("Must supply a database filename.\n");
+      exit(EXIT_FAILURE);
+  }
+
+  char* filename = argv[1];
+  Table* table = db_open(filename);
+
</span>   InputBuffer* input_buffer = new_input_buffer();
   while (true) {
     print_prompt();
</code></pre></div></div>

<p>And the diff to our tests:</p>
<div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code> describe 'database' do
<span class="gi">+  before do
+    `rm -rf test.db`
+  end
+
</span>   def run_script(commands)
     raw_output = nil
<span class="gd">-    IO.popen("./db", "r+") do |pipe|
</span><span class="gi">+    IO.popen("./db test.db", "r+") do |pipe|
</span>       commands.each do |command|
         pipe.puts command
       end
<span class="p">@@ -28,6 +32,27 @@</span> describe 'database' do
     ])
   end

+  it 'keeps data after closing connection' do
<span class="gi">+    result1 = run_script([
+      "insert 1 user1 person1@example.com",
+      ".exit",
+    ])
+    expect(result1).to match_array([
+      "db &gt; Executed.",
+      "db &gt; ",
+    ])
+
+    result2 = run_script([
+      "select",
+      ".exit",
+    ])
+    expect(result2).to match_array([
+      "db &gt; (1, user1, person1@example.com)",
+      "Executed.",
+      "db &gt; ",
+    ])
+  end
+
</span>   it 'prints error message when table is full' do
     script = (1..1401).map do |i|
       "insert #{i} user#{i} person#{i}@example.com"
</code></pre></div></div>


      
          <p><a class="prev" href="/db_tutorial/parts/part4.html">Part 4 - Our First Tests (and Bugs)</a> <br></p>
      
      
          <p><a class="next" href="/db_tutorial/parts/part6.html">Part 6 - The Cursor Abstraction</a> <br></p>
      

      </section>
      <footer>
        
        <p><a href="/db_tutorial/feed.xml">rss</a> | <a href="https://ifttt.com/applets/60708433d-rss-feed-to-email">subscribe by email</a></p>
        <p>This project is maintained by <a href="https://github.com/cstack">cstack</a></p>
        
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="/db_tutorial/assets/js/scale.fix.js"></script>


  
    <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-105767942-1', 'auto');
        ga('send', 'pageview');
    </script>
  
  </body>
</html>
