<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Part 6 - The Cursor Abstraction | Let’s Build a Simple Database</title>
<meta name="generator" content="Jekyll v3.9.5" />
<meta property="og:title" content="Part 6 - The Cursor Abstraction" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="This should be a shorter part than the last one. We’re just going to refactor a bit to make it easier to start the B-Tree implementation." />
<meta property="og:description" content="This should be a shorter part than the last one. We’re just going to refactor a bit to make it easier to start the B-Tree implementation." />
<link rel="canonical" href="https://cstack.github.io/db_tutorial/parts/part6.html" />
<meta property="og:url" content="https://cstack.github.io/db_tutorial/parts/part6.html" />
<meta property="og:site_name" content="Let’s Build a Simple Database" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-09-10T00:00:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Part 6 - The Cursor Abstraction" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2017-09-10T00:00:00+00:00","datePublished":"2017-09-10T00:00:00+00:00","description":"This should be a shorter part than the last one. We’re just going to refactor a bit to make it easier to start the B-Tree implementation.","headline":"Part 6 - The Cursor Abstraction","mainEntityOfPage":{"@type":"WebPage","@id":"https://cstack.github.io/db_tutorial/parts/part6.html"},"url":"https://cstack.github.io/db_tutorial/parts/part6.html"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="stylesheet" href="/db_tutorial/assets/css/style.css?v=60b50c5b7be787a4aaa1e50ab8a90c6cabb75159">
    <meta name="viewport" content="width=device-width">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>Let's Build a Simple Database</h1>
        <p>Writing a sqlite clone from scratch in C</p>

        <p class="view"><a href="/db_tutorial/">Overview</a></p>

        
          <p class="view"><a href="https://github.com/cstack/db_tutorial">View on GitHub (pull requests welcome)</a></p>
        

        

        

        <div style="color:#721c24;background-color:#f8d7da;border-color:#f5c6cb;padding:.75rem 1.25rem;border-radius:.25rem;margin-bottom:1rem">
          <p><b>This project is no longer under active development.</b> You can read more <a href="/db_tutorial/parts/part15.html">here</a>. But if you'd like to keep learning how to make your own SQLite clone from scratch, or one of many other projects like Docker, Redis, Git or BitTorrent, try <a href="https://app.codecrafters.io/join?via=cstack"><b>CodeCrafters</b></a>.</p>
        </div>
        <div>
          <a href="https://app.codecrafters.io/join?via=cstack"><img src="https://cstack.github.io/db_tutorial/assets/images/code-crafters.jpeg" alt=""/></a>
        </div>
      </header>
      <section>

      
      

      <h1>Part 6 - The Cursor Abstraction</h1>
      
          <p><a class="prev" href="/db_tutorial/parts/part5.html">Part 5 - Persistence to Disk</a> <br></p>
      
      
          <p><a class="next" href="/db_tutorial/parts/part7.html">Part 7 - Introduction to the B-Tree</a> <br></p>
      

      <p>This should be a shorter part than the last one. We’re just going to refactor a bit to make it easier to start the B-Tree implementation.</p>

<p>We’re going to add a <code class="language-plaintext highlighter-rouge">Cursor</code> object which represents a location in the table. Things you might want to do with cursors:</p>

<ul>
  <li>Create a cursor at the beginning of the table</li>
  <li>Create a cursor at the end of the table</li>
  <li>Access the row the cursor is pointing to</li>
  <li>Advance the cursor to the next row</li>
</ul>

<p>Those are the behaviors we’re going to implement now. Later, we will also want to:</p>

<ul>
  <li>Delete the row pointed to by a cursor</li>
  <li>Modify the row pointed to by a cursor</li>
  <li>Search a table for a given ID, and create a cursor pointing to the row with that ID</li>
</ul>

<p>Without further ado, here’s the <code class="language-plaintext highlighter-rouge">Cursor</code> type:</p>

<div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gi">+typedef struct {
+  Table* table;
+  uint32_t row_num;
+  bool end_of_table;  // Indicates a position one past the last element
+} Cursor;
</span></code></pre></div></div>

<p>Given our current table data structure, all you need to identify a location in a table is the row number.</p>

<p>A cursor also has a reference to the table it’s part of (so our cursor functions can take just the cursor as a parameter).</p>

<p>Finally, it has a boolean called <code class="language-plaintext highlighter-rouge">end_of_table</code>. This is so we can represent a position past the end of the table (which is somewhere we may want to insert a row).</p>

<p><code class="language-plaintext highlighter-rouge">table_start()</code> and <code class="language-plaintext highlighter-rouge">table_end()</code> create new cursors:</p>

<div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gi">+Cursor* table_start(Table* table) {
+  Cursor* cursor = malloc(sizeof(Cursor));
+  cursor-&gt;table = table;
+  cursor-&gt;row_num = 0;
+  cursor-&gt;end_of_table = (table-&gt;num_rows == 0);
+
+  return cursor;
+}
+
+Cursor* table_end(Table* table) {
+  Cursor* cursor = malloc(sizeof(Cursor));
+  cursor-&gt;table = table;
+  cursor-&gt;row_num = table-&gt;num_rows;
+  cursor-&gt;end_of_table = true;
+
+  return cursor;
+}
</span></code></pre></div></div>

<p>Our <code class="language-plaintext highlighter-rouge">row_slot()</code> function will become <code class="language-plaintext highlighter-rouge">cursor_value()</code>, which returns a pointer to the position described by the cursor:</p>

<div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gd">-void* row_slot(Table* table, uint32_t row_num) {
</span><span class="gi">+void* cursor_value(Cursor* cursor) {
+  uint32_t row_num = cursor-&gt;row_num;
</span>   uint32_t page_num = row_num / ROWS_PER_PAGE;
<span class="gd">-  void* page = get_page(table-&gt;pager, page_num);
</span><span class="gi">+  void* page = get_page(cursor-&gt;table-&gt;pager, page_num);
</span>   uint32_t row_offset = row_num % ROWS_PER_PAGE;
   uint32_t byte_offset = row_offset * ROW_SIZE;
   return page + byte_offset;
 }
</code></pre></div></div>

<p>Advancing the cursor in our current table structure is as simple as incrementing the row number. This will be a bit more complicated in a B-tree.</p>

<div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gi">+void cursor_advance(Cursor* cursor) {
+  cursor-&gt;row_num += 1;
+  if (cursor-&gt;row_num &gt;= cursor-&gt;table-&gt;num_rows) {
+    cursor-&gt;end_of_table = true;
+  }
+}
</span></code></pre></div></div>

<p>Finally we can change our “virtual machine” methods to use the cursor abstraction. When inserting a row, we open a cursor at the end of table, write to that cursor location, then close the cursor.</p>

<div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   Row* row_to_insert = &amp;(statement-&gt;row_to_insert);
<span class="gi">+  Cursor* cursor = table_end(table);
</span>
-  serialize_row(row_to_insert, row_slot(table, table-&gt;num_rows));
<span class="gi">+  serialize_row(row_to_insert, cursor_value(cursor));
</span>   table-&gt;num_rows += 1;

+  free(cursor);
<span class="gi">+
</span>   return EXECUTE_SUCCESS;
 }
</code></pre></div></div>

<p>When selecting all rows in the table, we open a cursor at the start of the table, print the row, then advance the cursor to the next row. Repeat until we’ve reached the end of the table.</p>

<div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code> ExecuteResult execute_select(Statement* statement, Table* table) {
<span class="gi">+  Cursor* cursor = table_start(table);
+
</span>   Row row;
<span class="gd">-  for (uint32_t i = 0; i &lt; table-&gt;num_rows; i++) {
-    deserialize_row(row_slot(table, i), &amp;row);
</span><span class="gi">+  while (!(cursor-&gt;end_of_table)) {
+    deserialize_row(cursor_value(cursor), &amp;row);
</span>     print_row(&amp;row);
<span class="gi">+    cursor_advance(cursor);
</span>   }
<span class="gi">+
+  free(cursor);
+
</span>   return EXECUTE_SUCCESS;
 }
</code></pre></div></div>

<p>Alright, that’s it! Like I said, this was a shorter refactor that should help us as we rewrite our table data structure into a B-Tree. <code class="language-plaintext highlighter-rouge">execute_select()</code> and <code class="language-plaintext highlighter-rouge">execute_insert()</code> can interact with the table entirely through the cursor without assuming anything about how the table is stored.</p>

<p>Here’s the complete diff to this part:</p>
<div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">@@ -78,6 +78,13 @@</span> struct {
 } Table;

+typedef struct {
<span class="gi">+  Table* table;
+  uint32_t row_num;
+  bool end_of_table; // Indicates a position one past the last element
+} Cursor;
+
</span> void print_row(Row* row) {
     printf("(%d, %s, %s)\n", row-&gt;id, row-&gt;username, row-&gt;email);
 }
<span class="p">@@ -126,12 +133,38 @@</span> void* get_page(Pager* pager, uint32_t page_num) {
     return pager-&gt;pages[page_num];
 }

-void* row_slot(Table* table, uint32_t row_num) {
<span class="gd">-  uint32_t page_num = row_num / ROWS_PER_PAGE;
-  void *page = get_page(table-&gt;pager, page_num);
-  uint32_t row_offset = row_num % ROWS_PER_PAGE;
-  uint32_t byte_offset = row_offset * ROW_SIZE;
-  return page + byte_offset;
</span><span class="gi">+Cursor* table_start(Table* table) {
+  Cursor* cursor = malloc(sizeof(Cursor));
+  cursor-&gt;table = table;
+  cursor-&gt;row_num = 0;
+  cursor-&gt;end_of_table = (table-&gt;num_rows == 0);
+
+  return cursor;
+}
+
+Cursor* table_end(Table* table) {
+  Cursor* cursor = malloc(sizeof(Cursor));
+  cursor-&gt;table = table;
+  cursor-&gt;row_num = table-&gt;num_rows;
+  cursor-&gt;end_of_table = true;
+
+  return cursor;
+}
+
+void* cursor_value(Cursor* cursor) {
+  uint32_t row_num = cursor-&gt;row_num;
+  uint32_t page_num = row_num / ROWS_PER_PAGE;
+  void *page = get_page(cursor-&gt;table-&gt;pager, page_num);
+  uint32_t row_offset = row_num % ROWS_PER_PAGE;
+  uint32_t byte_offset = row_offset * ROW_SIZE;
+  return page + byte_offset;
+}
+
+void cursor_advance(Cursor* cursor) {
+  cursor-&gt;row_num += 1;
+  if (cursor-&gt;row_num &gt;= cursor-&gt;table-&gt;num_rows) {
+    cursor-&gt;end_of_table = true;
+  }
</span> }

 Pager* pager_open(const char* filename) {
<span class="p">@@ -327,19 +360,28 @@</span> ExecuteResult execute_insert(Statement* statement, Table* table) {
     }

   Row* row_to_insert = &amp;(statement-&gt;row_to_insert);
<span class="gi">+  Cursor* cursor = table_end(table);
</span>
-  serialize_row(row_to_insert, row_slot(table, table-&gt;num_rows));
<span class="gi">+  serialize_row(row_to_insert, cursor_value(cursor));
</span>   table-&gt;num_rows += 1;

+  free(cursor);
<span class="gi">+
</span>   return EXECUTE_SUCCESS;
 }

 ExecuteResult execute_select(Statement* statement, Table* table) {
<span class="gi">+  Cursor* cursor = table_start(table);
+
</span>   Row row;
<span class="gd">-  for (uint32_t i = 0; i &lt; table-&gt;num_rows; i++) {
-     deserialize_row(row_slot(table, i), &amp;row);
</span><span class="gi">+  while (!(cursor-&gt;end_of_table)) {
+     deserialize_row(cursor_value(cursor), &amp;row);
</span>      print_row(&amp;row);
<span class="gi">+     cursor_advance(cursor);
</span>   }
<span class="gi">+
+  free(cursor);
+
</span>   return EXECUTE_SUCCESS;
 }
</code></pre></div></div>


      
          <p><a class="prev" href="/db_tutorial/parts/part5.html">Part 5 - Persistence to Disk</a> <br></p>
      
      
          <p><a class="next" href="/db_tutorial/parts/part7.html">Part 7 - Introduction to the B-Tree</a> <br></p>
      

      </section>
      <footer>
        
        <p><a href="/db_tutorial/feed.xml">rss</a> | <a href="https://ifttt.com/applets/60708433d-rss-feed-to-email">subscribe by email</a></p>
        <p>This project is maintained by <a href="https://github.com/cstack">cstack</a></p>
        
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="/db_tutorial/assets/js/scale.fix.js"></script>


  
    <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-105767942-1', 'auto');
        ga('send', 'pageview');
    </script>
  
  </body>
</html>
